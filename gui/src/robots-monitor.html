<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/state-display/state-display.html">

<dom-module id="robots-monitor">
  <template strip-whitespace>
    <style>
      :host {
        display:block;
      }

      h2{
        text-align:center;
      }

      #cv{
        display:block;
        width:100%;
      }

      .robots{
        display:inline-block;
        width:calc(100% / 3);
      }
    </style>

    <h2><state-display state="[[connected]]">rotbots monitor</state-display></h2>
    <canvas id="cv"></canvas>
    <canvas class="robots" id="top"></canvas>
    <canvas class="robots" id="front"></canvas>
    <canvas class="robots" id="right"></canvas>
  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
    class RoboterMonitor extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
      static get is() { return 'robots-monitor'; }
      static get properties() {
        return {
          host: {
            type: String,
            value: window.location.hostname,
            observer: '_connect'
          },
          port: {
            type: Number,
            value: window.location.port,
            observer: '_connect'
          },
          resource: {
            type: String,
            value: '',
            observer: '_connect'
          },
          connected: {
            type: String,
            value: 'red'
          },
          maxCurrent: {
            type: Number,
            value: 100
          },
          maxVoltage: {
            type: Number,
            value: 20
          },
          carrierBountingBox: {
            type: Object,
            value: {
              min: {x: 0, y: 0, z: 0},
              max: {x: 10, y: 10, z: 10}
            }
          },
          robotBountingBox: {
            type: Object,
            value: {
              min: {x: 0, y: 0, z: 0},
              max: {x: 10, y: 10, z: 10}
            }
          }
        };
      }

      constructor() {
        super();

        // don't try to connect until the DOM is ready
        this.domReady = false;
        this.connection_try = null;

        // buffer over the last 2 seconds
        this.currentBuffer = new Array(200).fill(0);
        this.voltageBuffer = new Array(200).fill(0);

        this.carrier = {x: 2, y: 2, z: 2};
        this.robot = {time: 0, x: 0, y: 0, z: 0, roll: 0, yaw: 0, pitch: 0,
          current: 0, voltage: 0};

      }

      ready(){
        super.ready();

        this.addEventListener('iron-resize', this._resize);

        setInterval(this._drawCurrentAndVoltage.bind(this), 500);
        setInterval(function(){
            this.currentBuffer.shift();
            this.currentBuffer.push(0);
            this.voltageBuffer.shift();
            this.voltageBuffer.push(0);
          }.bind(this), 100);

        this.domReady = true;

        this._connect();

        this._drawCurrentAndVoltage();
        this._drawRobots();
      }

      _connect(){
        if(!this.domReady) return;

        this.websocket = new WebSocket('ws://' + this.host + ':' +
          parseInt(this.port) + '/' + this.resource)

        this.websocket.onopen = function(){
            this.connected = 'green';
          }.bind(this);

        this.websocket.onclose = function(event){
            console.log('WebSocket Closed: ' + event.reason);
            this.connected = 'red';
            this._connect();
          }.bind(this);

        this.websocket.onmessage = function(event){
            if(typeof event.data === "string"){
              let json = JSON.parse(event.data);
              switch(json.type){
                case 'carrier':
                  this.carrier = {x: json.x, y: json.y, z: json.z};

                  this._drawRobots();
                break;
                case 'robot':
                  this.robot = {
                      time: json.time,
                      x: json.x, y: json.y, z: json.z,
                      roll: json.roll, yaw: json.yaw, pitch: json.pitch,
                      current: json.current, voltage: json.voltage
                    };

                  this.currentBuffer[this.currentBuffer.length - 1] =
                    json.current;
                  this.voltageBuffer[this.voltageBuffer.length - 1] =
                    json.voltage;

                  this._drawRobots();
                break;
                case 'init':
                  this.carrierBountingBox = json.carrier_minmax;
                  this.robotBountingBox = json.robot_minmax;
                  this.maxCurrent = json.max_current;
                  this.maxVoltage = json.max_voltage;
                  this.carrier = json.carrier;
                  this.robot = json.robot;

                  this._drawRobots();
                break;
                default:
                  console.log("unknown json message type " + json.type);
              }
            }else{
              console.log("message type is not string");
            }
          }.bind(this);
      }

      _drawRobots(){
        this._drawTop();
        this._drawFront();
        this._drawRight();
      }

      _drawTop(){
        const ctx = this.$.top.getContext('2d');
        const s = this.$.top.width;
        ctx.clearRect(0, 0, s, s);

        let min = this.carrierBountingBox.min;
        let max = this.carrierBountingBox.max;
        let diff = {x: max.x - min.x, y: max.y - min.y, z: max.z - min.z};

        let c = this.carrier;
        let r = this.robot;

        // border around the cell
        let b = 0.15 * s;

        // carrier size in the drawing
        let ps = 0.1 * s;

        ctx.strokeRect(b, b, s - 2 * b, s - 2 * b);
        let local_x = b + (c.x - min.x) / diff.x * (s - 2 * b);
        let local_y = b + (c.y - min.y) / diff.y * (s - 2 * b);
        let robot_x = local_x + r.x / diff.x * (s - 2 * b);
        let robot_y = local_y + r.y / diff.y * (s - 2 * b);

        // draw carrier
        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.moveTo(b, b);
        ctx.lineTo(local_x - ps / 2, local_y - ps / 2);
        ctx.moveTo(b, (s - b));
        ctx.lineTo(local_x - ps / 2, local_y + ps / 2);
        ctx.moveTo((s - b), b);
        ctx.lineTo(local_x + ps / 2, local_y - ps / 2);
        ctx.moveTo((s - b), (s - b));
        ctx.lineTo(local_x + ps / 2, local_y + ps / 2);
        ctx.stroke();
        ctx.strokeRect(local_x - ps / 2, local_y - ps / 2, ps, ps);

        // draw robot
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.arc(local_x, local_y, ps / 8, 0, 2 * Math.PI);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(local_x, local_y);
        ctx.lineTo(robot_x, robot_y);
        ctx.stroke();

        // Draw the headline in the right top corner
        ctx.strokeStyle = 'black';
        ctx.font = s / 40 * 3 + "px Sans Serif";
        ctx.lineWidth = s / 800 * 3;
        let y_pos = s / 40 * 3 + s / 2000 * 3;
        ctx.fillText("top", s / 150 * 3, y_pos);

        ctx.strokeRect(0, 0, s, s);
      }

      _drawFront(){
        const ctx = this.$.front.getContext('2d');
        const s = this.$.top.width;
        ctx.clearRect(0, 0, s, s);

        let min = this.carrierBountingBox.min;
        let max = this.carrierBountingBox.max;
        let diff = {x: max.x - min.x, y: max.y - min.y, z: max.z - min.z};

        let c = this.carrier;
        let r = this.robot;

        // border around the cell
        let b = 0.15 * s;

        // carrier size in the drawing
        let ps = 0.1 * s;

        ctx.beginPath();
        ctx.moveTo(b, s - b);
        ctx.lineTo(b, b);
        ctx.lineTo(s - b, b);
        ctx.lineTo(s - b, s - b);
        ctx.stroke();

        let local_x = b + (c.x - min.x) / diff.x * (s - 2 * b);
        let local_z = b + (c.z - min.z) / diff.z * (s - 2 * b);
        let robot_x = local_x + r.x / diff.x * (s - 2 * b);
        let robot_z = local_z + r.z / diff.z * (s - 2 * b);


        // draw carrier
        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.moveTo(b, b);
        ctx.lineTo(local_x - ps / 2, local_z - ps / 20);
        ctx.moveTo((s - b), b);
        ctx.lineTo(local_x + ps / 2, local_z - ps / 20);
        ctx.stroke();
        ctx.strokeRect(local_x - ps / 2, local_z - ps / 20, ps, ps / 10);


        // draw robot
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.arc(local_x, local_z, ps / 8, 0, 2 * Math.PI);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(local_x, local_z);
        ctx.lineTo(robot_x, robot_z);
        ctx.stroke();


        // Draw the headline in the right top corner
        ctx.strokeStyle = 'black';
        ctx.font = s / 40 * 3 + "px Sans Serif";
        ctx.lineWidth = s / 800 * 3;
        let y_pos = s / 40 * 3 + s / 2000 * 3;
        ctx.fillText("front", s / 150 * 3, y_pos);

        ctx.strokeRect(0, 0, s, s);
      }

      _drawRight(){
        const ctx = this.$.right.getContext('2d');
        const s = this.$.top.width;
        ctx.clearRect(0, 0, s, s);

        let min = this.carrierBountingBox.min;
        let max = this.carrierBountingBox.max;
        let diff = {x: max.x - min.x, y: max.y - min.y, z: max.z - min.z};

        let c = this.carrier;
        let r = this.robot;

        // border around the cell
        let b = 0.15 * s;

        // carrier size in the drawing
        let ps = 0.1 * s;

        ctx.beginPath();
        ctx.moveTo(b, s - b);
        ctx.lineTo(b, b);
        ctx.lineTo(s - b, b);
        ctx.lineTo(s - b, s - b);
        ctx.stroke();

        let local_y = b + (diff.y - (c.y - min.z)) / diff.y * (s - 2 * b);
        let local_z = b + (c.z - min.z) / diff.z * (s - 2 * b);
        let robot_y = local_y + r.y / diff.y * (s - 2 * b);
        let robot_z = local_z + r.z / diff.z * (s - 2 * b);

        // draw carrier
        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.moveTo(b, b);
        ctx.lineTo(local_y - ps / 2, local_z - ps / 20);
        ctx.moveTo((s - b), b);
        ctx.lineTo(local_y + ps / 2, local_z - ps / 20);
        ctx.stroke();
        ctx.strokeRect(local_y - ps / 2, local_z - ps / 20, ps, ps / 10);


        // draw robot
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.arc(local_y, local_z, ps / 8, 0, 2 * Math.PI);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(local_y, local_z);
        ctx.lineTo(robot_y, robot_z);
        ctx.stroke();


        // Draw the headline in the right top corner
        ctx.strokeStyle = 'black';
        ctx.font = s / 40 * 3 + "px Sans Serif";
        ctx.lineWidth = s / 800 * 3;
        let y_pos = s / 40 * 3 + s / 2000 * 3;
        ctx.fillText("right", s / 150 * 3, y_pos);

        ctx.strokeRect(0, 0, s, s);
      }

      _drawCurrentAndVoltage(){
        const ctx = this.$.cv.getContext('2d');
        const w = this.$.cv.width;
        const h = this.$.cv.height;
        ctx.clearRect(0, 0, w, h);

        let max = Math.max(this.maxCurrent, this.maxVoltage);

        [
          {buffer: this.currentBuffer, text: 'current'},
          {buffer: this.voltageBuffer, text: 'voltage'}
        ].map(function(this_){
          let local_x = (i) => i / this_.buffer.length * w + w / this_.buffer.length / 2;
          let local_y = (i) => (h - this_.buffer[i] / max * 0.9 * h) - 0.05 * h;

          ctx.strokeStyle = this_.text == 'current' ? 'red' : 'blue';
          ctx.fillStyle = ctx.strokeStyle;
          ctx.beginPath();
          ctx.moveTo(local_x(0), local_y(0));
          for(let i = 1; i < this_.buffer.length; ++i){
            ctx.lineTo(local_x(i), local_y(i));
          }
          ctx.stroke();

          // Draw the headline in the right top corner
          ctx.strokeStyle = 'black';
          ctx.font = h / 4 + "px Sans Serif";
          ctx.lineWidth = h / 80;
          let y_pos = h / 4 + h / 20;
          if(this_.text != 'current'){
            y_pos += h / 4;
          }
          ctx.strokeText(this_.text, h / 15, y_pos);
          ctx.fillText(this_.text, h / 15, y_pos);
        }.bind(this));

        ctx.strokeRect(0, 0, w, h);
      }

      _resize(){
        this.$.cv.width = this.$.cv.clientWidth;
        this.$.cv.height = this.$.cv.clientWidth / 10;

        this.$.top.width = this.$.cv.width / 3;
        this.$.top.height = this.$.cv.width / 3;
        this.$.front.width = this.$.cv.width / 3;
        this.$.front.height = this.$.cv.width / 3;
        this.$.right.width = this.$.cv.width / 3;
        this.$.right.height = this.$.cv.width / 3;

        this._drawRobots();
        this._drawCurrentAndVoltage();
      }
    }

    window.customElements.define(RoboterMonitor.is, RoboterMonitor);
  </script>
</dom-module>
